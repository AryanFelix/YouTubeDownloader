name: Build & Release

on:
  push:
    tags:
      - "v*.*.*"

permissions:
  contents: write
  packages: write
  id-token: write

env:
  PYINSTALLER_SPEC: main.spec
  ENTRY_SCRIPT: main.py
  APP_NAME: YouTubeDownloader

jobs:
  build:
    name: Build for ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [windows-latest, ubuntu-latest, macos-latest]
        python: [3.11]
    outputs:
      artifact-name: ${{ steps.set-artifact-name.outputs.artifact-name }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python ${{ matrix.python }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python }}

      - name: Set artifact name
        id: set-artifact-name
        run: |
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            echo "::set-output name=artifact-name::${{ env.APP_NAME }}-windows-${GITHUB_REF_NAME}.zip"
          elif [[ "${{ matrix.os }}" == "ubuntu-latest" ]]; then
            echo "::set-output name=artifact-name::${{ env.APP_NAME }}-linux-${GITHUB_REF_NAME}.tar.gz"
          else
            echo "::set-output name=artifact-name::${{ env.APP_NAME }}-macos-${GITHUB_REF_NAME}.tar.gz"
          fi

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          pip install pyinstaller

      - name: Install ffmpeg (platform)
        run: |
          if [[ "${{ matrix.os }}" == "ubuntu-latest" ]]; then
            sudo apt-get update
            sudo apt-get install -y ffmpeg
          elif [[ "${{ matrix.os }}" == "macos-latest" ]]; then
            brew update || true
            brew install ffmpeg || true
          elif [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            choco install -y ffmpeg
          fi

      - name: Prepare build folder
        run: |
          mkdir -p build_artifact

      - name: Build with PyInstaller
        env:
          PYTHONUNBUFFERED: 1
        run: |
          # Choose the correct --add-data separator for pyinstaller per-platform
          # - Windows: src;dest (use semicolon)
          # - POSIX (linux/mac): src:dest (use colon)
          ADD_DATA=""
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            # include assets and (optional) an ffmpeg folder if present in repo
            # bundling your own assets folder: "assets;assets"
            ADD_DATA="assets;assets"
            pyinstaller --noconfirm --onefile --name "${{ env.APP_NAME }}.exe" --add-data "$ADD_DATA" "${{ env.ENTRY_SCRIPT }}"
            # resulting file: dist\YouTubeDownloader.exe
          else
            ADD_DATA="assets:assets"
            pyinstaller --noconfirm --onefile --name "${{ env.APP_NAME }}" --add-data "$ADD_DATA" "${{ env.ENTRY_SCRIPT }}"
            # resulting file: dist/YouTubeDownloader
          fi

      - name: Bundle runtime files
        run: |
          mkdir -p artifact
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            if [ -f dist/${{ env.APP_NAME }}.exe ]; then
              cp dist/${{ env.APP_NAME }}.exe artifact/
            else
              echo "ERROR: expected executable dist/${{ env.APP_NAME }}.exe not found" && exit 1
            fi
            # optionally include bundled ffmpeg folder if you put one into repo or want to ship it
            if [ -d ffmpeg ]; then
              cp -r ffmpeg artifact/
            fi
            # zip artifact folder
            powershell -Command "Compress-Archive -Path artifact/* -DestinationPath ${GITHUB_WORKSPACE}/${{ steps.set-artifact-name.outputs.artifact-name }}"
          else
            # POSIX: tar.gz
            if [ -f dist/${{ env.APP_NAME }} ]; then
              cp dist/${{ env.APP_NAME }} artifact/
            else
              echo "ERROR: expected executable dist/${{ env.APP_NAME }} not found" && exit 1
            fi
            if [ -d ffmpeg ]; then
              cp -r ffmpeg artifact/
            fi
            tar -czf "${GITHUB_WORKSPACE}/${{ steps.set-artifact-name.outputs.artifact-name }}" -C artifact .
          fi

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.set-artifact-name.outputs.artifact-name }}
          path: ${{ github.workspace }}/${{ steps.set-artifact-name.outputs.artifact-name }}

  create-release:
    name: Create Release and attach artifacts
    needs: build
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')
    steps:
      - name: Download artifacts from build jobs
        uses: actions/download-artifact@v4
        with:
          path: downloaded_artifacts

      - name: List downloaded artifacts
        run: ls -la downloaded_artifacts || true

      - name: Create GitHub Release
        id: create_release
        uses: actions/create-release@v1
        with:
          tag_name: ${{ github.ref_name }}
          release_name: Release ${{ github.ref_name }}
          body: Automated release generated by GitHub Actions
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload release assets
        run: |
          set -e
          for f in downloaded_artifacts/*; do
            echo "Uploading $f"
            gh_release_asset_name="$(basename "$f")"
            # Use curl to upload via GitHub REST API (safer cross-version)
            upload_url=$(jq -r .upload_url < "${GITHUB_WORKSPACE}/.github/release_response.json" 2>/dev/null || true)
            # fallback to using actions/upload-release-asset if API response not present
            if [ -z "$upload_url" ]; then
              # Use official action to upload single asset
              echo "Using actions/upload-release-asset to upload $f"
              gh release upload "${{ github.ref_name }}" "$f" --clobber || true
            else
              echo "Custom upload path (not used)."
            fi
          done
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash

      - name: Confirm release
        run: echo "Release ${GITHUB_REF_NAME} created and artifacts uploaded."

